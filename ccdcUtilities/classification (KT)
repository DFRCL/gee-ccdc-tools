
/** ///////////////////////////////////////////////////////////////////
 * 
 * Utility functions for classifying CCDC
 * 
 ** /////////////////////////////////////////////////////////////////*/
var inputUtils = require('projects/GLANCE:ccdcUtilities/inputs')
var dateUtils = require('projects/GLANCE:ccdcUtilities/dates')
var ccdcUtils = require('projects/GLANCE:ccdcUtilities/ccdc')
var uiUtils = require('projects/GLANCE:ccdcUtilities/ui') 




/**
 * Convert training data to binary label for target class
 * 
 * @param {ee.Dict}      option        Parameter file containing the keys below
*   @key   {ee.FC}       fc            Training data feature collection
*   @key   {String}      property      Property label indicating class label
*   @key   {Number}      targetClass   Class to retain as 1 in binary label
* 
* @returns {ee.FC}                     Training data where 1 = targetClass and 0 equals all other classes
*/

var getBinaryLabel = function(options) {
  
  var fc = (options && options.fc) || null
  var property = (options && options.property) || 'label'
  var targetClass = (options && options.targetClass) || null
  
  if (!fc) {
    return('Required argument [fc] missing.')
  }
  if (!targetClass) {
    return('Required argument [targetClass] missing.')
  }
  
  fc = ee.FeatureCollection(fc)
  
  
  var targetFc = fc.filterMetadata(property,'equals',targetClass).map(function(i) {
    return i.set(property, 1)
  })
  var notTargetFc = fc.filterMetadata(property,'not_equals',targetClass).map(function(i) {
    return i.set(property, 0)
  })
  
  return targetFc.merge(notTargetFc)
}


/**
 * Get class probability for each class in training data
 * 
 * @param {dictionary}        options           parameter file
 * @key   {ee.Image}          coefsToClassify   multi-band image of coefficients to classify
 * @key   {list}              classList         classes to test probability of
 * @key   {ee.FC}             fc                feature collection of training data
 * @key   {ee.Classifier}     classifier        classifier in 'PROBABILITY' mode
 * @key   {string}            property          label defining class in training data
 * 
 * @returns {ee.Image}                          image with each band being class probability for each input class
 */
 
var getClassProbs = function(options) {
  var fc = (options && options.fc) || null
  var coefsToClassify = (options && options.coefsToClassify) || null
  var classList = (options && options.classList) || null
  var classifier = (options && options.classifier) || null
  var property = (options && options.property) || 'lc_class_c'
  
  if (!coefsToClassify) {
    return('Required parameter [coefsToClassify] missing')
  }
  
  if (!classList) {
    return('Required parameter [classList] missing')
  }
  if (!classifier) {
    return('Required parameter [classifier] missing')
  }
  if (!fc) {
    return('Required parameter [fc] missing')
  }
  var bandNames = classList.map(function(num) {
    return ee.String('probability_').cat(ee.String(num))
  })
  var classProbs = classList.map(function(num) {
    var fcBinary = getBinaryLabel({fc:fc, property: property, targetClass: num})
    var trained = classifier.train({
        features: fcBinary,
        classProperty: property,
        inputProperties: coefsToClassify.bandNames()
      })
    return coefsToClassify.classify(trained)//.rename(ee.String('probability_').cat(ee.String(num)))
    
  })
  return ee.ImageCollection(ee.List(classProbs)).toBands().rename(bandNames)
}


 
/**
 * Make random grids in a region of interest
 * 
 * @param {geometry}    region      study region bounding geometry
 * @param {Number}      count       number of random grids
 * @param {Number}      size        length of one side of grid in m^2
 * @param {Number}      seed        random number seed or 'random'
 * 
 * @returns {ee.FC}                 feature collection of random grids
 */ 
var makeGrids = function(region, count, size, seed) {
  
  if (seed == 'random') {
    seed = Math.ceil(Math.random() * 1000)
  }

  // Create sample of random points within region
  var randomPoints = ee.FeatureCollection.randomPoints({
    region: region,
    points: count,
    seed: seed
  })
  
  // Take bounding box of buffered samples
  var bb =randomPoints.map(function(point) {
    var buffer = point.buffer(size/2)
    return buffer.bounds()
  })
  
  // Assign id
  var bbList = bb.toList(bb.size());
  var indexList = ee.List.sequence(1, bb.size());
  
  return ee.FeatureCollection(indexList.map(function(i) {
    return ee.Feature(bbList.get(
      ee.Number(i).subtract(1)))
      .set( {ID: i} );
  }))
  
}



/**
 * Take subset of training data within single tile
 * 
 */
var subsetSingleTraining = function(tile, training) {
  return training.filterBounds(tile)
}

/**
 * Take subset of training data in all tiles
 * 
 */
var subsetAllTraining = function(tiles, training) {
  return tiles.map(function(t) {
    return training
      .filterBounds(t.geometry())
      .set( {ID: t.get('ID')} );
  })
}





/**
* Get training coefficient by reading from result data
* 
* 
* @param {ee.Dict}        options         Parameter file containing the keys below
*   @key {ee.FC}          trainingData    training data with ccdc outputs saved in properties in addition to a date property
*   @key {List}           bandList        list of input band names in order
*   @key {List}           coefNames       coefficient abbreviated names in order of results
*   @key {String}         dateProperty    property name containing date in features
*   @key {dict}           landsatParams   parameters for 'getLandsat' function
*   @key {ee.Image}       ccdcImage       Use ccdc coefficients instead of calculating on the fly
*   @key {List}           segs            Segment identifiers for ccdcImage parameter
* 
* @returns                ee.FC           training data with coefficients corresponding to specific date
*  
*/
var sampleResultProcedure = function(options) {
  var trainingData = (options && options.trainingData) || null
  var coefNames = (options && options.coefNames) ||  ['INTP','SLP','COS','SIN','RMSE','COS2','SIN2','COS3','SIN3']
  var bandList = (options && options.bandList) || ['BLUE','GREEN','RED','NIR','SWIR1','SWIR2']
  var dateProperty = (options && options.dateProperty) || 'Start_Year'
  var extraBands = (options && options.extraBands) || null
  var landsatParams = (options && options.landsatParams) || {start: '1990-01-01',end: '2020-01-01'}
  var resultImage = (options && options.ccdcImage) || null
  var segs = (options && options.segs) || ["S1", "S2", "S3", "S4", "S5", "S6"]
  var ccdcDateFmt = (options && options.ccdcDateFmt) || 1
  var trainingDateFm = (options && options.dateFormat) || 1
  var scale = (options && options.scale) || 30
  ccdcDateFmt = Number(ccdcDateFmt)
  var uniqueYears = ee.Dictionary(
    ee.FeatureCollection(
      trainingData).aggregate_histogram(dateProperty)).keys()
  return ee.FeatureCollection(uniqueYears.map(function(strYear) {
    // var strYear = '2010'
    var year = ee.Number.parse(strYear)
    var fcYear = trainingData.filterMetadata(dateProperty,'equals',year)
 
    var formattedDate = dateUtils.convertDate({
      inputFormat: trainingDateFm,
      inputDate: year,
      outputFormat: ccdcDateFmt // jdays
    })
    var coefs = ccdcUtils.get_multi_coefs(resultImage, formattedDate, bandList, coefNames, true, segs, 'after')

    var phaseAmps1 = ccdcUtils.phaseAmplitude(coefs, bandList, '_SIN', '_COS')
    var phaseAmps2 = ccdcUtils.phaseAmplitude(coefs, bandList, '_SIN2', '_COS2')
    var phaseAmps3 = ccdcUtils.phaseAmplitude(coefs, bandList, '_SIN3', '_COS3')

    coefs = coefs.addBands(ee.Image.cat([phaseAmps1, phaseAmps2, phaseAmps3]))
  
    if (extraBands) {
      coefs = coefs.addBands(extraBands)
    }
    return coefs.sampleRegions({
      collection: fcYear,
      scale: scale,
      tileScale: 16,
      geometries: true
    })

  })).flatten()

}
/**
* Get training coefficient by running ccdc on every feature
* 
* 
* @param {ee.Dict}        options         Parameter file containing the keys below
*   @key {ee.FC}          trainingData    training data with ccdc outputs saved in properties in addition to a date property
*   @key {List}           bandList        list of input band names in order
*   @key {List}           coefNames       coefficient abbreviated names in order of results
*   @key {String}         dateProperty    property name containing date in features
*   @key {dict}           landsatParams   parameters for 'getLandsat' function
*   @key {ee.Image}       ccdcImage       Use ccdc coefficients instead of calculating on the fly
*   @key {List}           segs            Segment identifiers for ccdcImage parameter
* 
* @returns                ee.FC           training data with coefficients corresponding to specific date
*  
*/
var runCcdcProcedure = function(options) {
  var trainingData = (options && options.trainingData) || null
  var coefNames = (options && options.coefNames) ||  ['INTP','SLP','COS','SIN','RMSE','COS2','SIN2','COS3','SIN3']
  var bandList = (options && options.bandList) || ['BLUE','GREEN','RED','NIR','SWIR1','SWIR2']
  var dateProperty = (options && options.dateProperty) || 'Start_Year'
  var extraBands = (options && options.extraBands) || null
  var landsatParams = (options && options.landsatParams) || {start: '1990-01-01',end: '2020-01-01'}
  var resultImage = (options && options.ccdcImage) || null
  var segs = (options && options.segs) || ["S1", "S2", "S3", "S4", "S5", "S6"]
  
  var trainingCCDC = getTraining({
    trainingData: trainingData, 
    extraBands: extraBands, 
    landsatParams: landsatParams
  })
  
  return trainingData.map(function(feat) { 
    var year = ee.Number(feat.get(dateProperty)).add(2)
    var year2 = ee.String(year)
    var date =dateUtils.dateToJdays(year2)
  
    var newccd = ccdcUtils.newFillNoData(trainingCCDC, 8, 6)
  
    var ccdImage = ccdcUtils.newBuildCcdcImage(newccd, 6, bandList)
  
    var coefs = ccdcUtils.get_multi_coefs(ccdImage, date, bandList, coefNames, true, segs)
    
    if (extraBands) {
      coefs = coefs.addBands(extraBands)
    }
    
    var sampleCoefs = ee.Dictionary(coefs.reduceRegion({
        reducer: ee.Reducer.mean(),
        geometry: feat.geometry(),
        scale: 30,
        crs: 'EPSG:4326',
        tileScale: 8,
      }))
  
  return ee.Feature(feat).setMulti(sampleCoefs)
  
  })
}

/**
* Get coefficients at a given date for each feature in collection
* 
* 
* @param {ee.Dict}        options         Parameter file containing the keys below
*   @key {ee.FC}          trainingData    training data with ccdc outputs saved in properties in addition to a date property
*   @key {List}           bandList        list of input band names in order
*   @key {List}           coefNames       coefficient abbreviated names in order of results
*   @key {String}         dateProperty    property name containing date in features
*   @key {dict}           landsatParams   parameters for 'getLandsat' function
*   @key {ee.Image}       ccdcImage       Use ccdc coefficients instead of calculating on the fly
*   @key {List}           segs            Segment identifiers for ccdcImage parameter
* 
* @returns                ee.FC           training data with coefficients corresponding to specific date
*  
*/
var getTrainingCoefsAtDate = function(options) {

  var resultImage = (options && options.ccdcImage) || null

  if (resultImage) {
    return sampleResultProcedure(options)
  } else {
    return runCcdcProcedure(options)
  }
}


/** 
* Create subset of training data
* 
* @param   {FC}          feats      Training data feature collection
* @param   {Number}      num        Number of training data per class
* @param   {String}      property   Land cover label property
* 
* @returns {ee.FC}                  Reduced randomized training data
*/ 
var subsetTraining = function(feats, num,property) {
  var unique = ee.Dictionary(feats.aggregate_histogram(property)).keys()
  return ee.FeatureCollection(unique.map(function(key) {
    var thisClass = feats.filterMetadata(property,'equals',ee.Number.parse(key))
    var random = thisClass.randomColumn('random').sort('random')
    return ee.FeatureCollection(random.toList(num))
  })).flatten()
}

/** 
* Get the middle segment date of training data
* 
* @param   {FC}          fc         Training data feature collection
* @param   {String}      startProp  Property name of segment start year
* @param   {String}      endProp    Property name of segment end year
* 
* @returns {ee.FC}                  Training data with 'Middle_year' attribute
*/ 
var getMiddleDate = function(fc, startProp, endProp) {
  return fc.map(function(feat) {
    var start = ee.Number(feat.get(startProp))
    var end = ee.Number(feat.get(endProp))
    var middle = (start.add(end)).divide(2).ceil().int16()
    return feat.set('Middle_year',middle)
  })
}


/** 
* Train a classifier
* 
* @param   {FC}          points          Training data feature collection
* @param   {String}      classProperty   Property name of class label
* @param   {List}        inputProperties List of properties to train on
* @param   {ee.Class.}   classifier      ee.Classifier with parameters
* 
* @returns {ee.Class.}                   ee.Classifier trained on inputs
*/ 
var train = function(points, classProperty, inputProperties, classifier) {
  
  return classifier.train({
    features: points,
    classProperty: classProperty,
    inputProperties: inputProperties,
  })
}

/**
 * Use all training data and perform classification
 * 
 * 
 */ 
var trainAndClassify = function(points, classProperty, inputProperties, classifier, image) {
  var trained = train(points, classProperty, inputProperties, classifier)
  return image.classify(trained)
}

/** 
* Train and classify within a "mushroom" grid
* 
* @param   {FC}          points         Training data feature collection with coefficients matching coefImage bands
* @param   {ee.Image}    coefImage      Image of coefficients to classify
* @param   {FC}          grid           Feature collection of "mushroom" grids
* @param   {String}      property       Property with land cover label in 'points' FC
* @param   {String}      classifyDate   Date to perform classification in format 'YYYY-MM-DD'
* @param   {ee.Class.}   classifier     ee.Classifier with parameters
* @param   {Number}      randomPoints   Number of random points from each class to take from 'points'   
* 
* @returns {Obj}                        Collection of classification results for each grid              
*/ 
var classifyGrids = function(points, coefImage, grid, property, classifyDate, classifier, randomPoints) {
  return grid.map(function(ext) {
    var geo = ext.geometry() 
    // Get training data within geometry of grid
    var feats = points.filterBounds(geo)
    // Get random subset of 'global' training data: 
    if (randomFeats > 0) {
      var randomFeats = ee.FeatureCollection(subsetTraining(points, randomPoints, property))
      feats = feats.merge(randomFeats)
    }
    // Train and classify
    var trained = train(feats, property, coefImage.bandNames(), classifier)

    return coefImage.clip(geo).classify(trained)
  })
}

// Remap training labels to GLANCE level 1 land cover
var remapLC = function(feats, inLabel, outLabel) {
  var feats = feats.map(function(feat) {
    return feat.set(outLabel,feat.get(inLabel))
  })
  
  return feats.remap(
    ['Snow/Ice','Water','Bare','Developed','Forest','Herbaceous','Shrub'],
    [1,2,3,4,5,6,7],
    outLabel
  )  
}



//.................. UI APP .......................//

//............. TRAINING SAMPLING ................//

/**
 * Choose method for subsetting training data. Currently,
 * there is support for:
 * 
 * 1. Using all the training data
 * 2. Using only the data within a random selection of grid points
 * 3. Using all the training data with a subset of the full data
 * 
 */
var training = function(theMap, visLabels) {
  var self = this
  this.widgs = {}
  // this.outGeo = outGeo

  this.trainingOptions = ['Use All','Within Output Extent']
  this.trainingStrategy = 'Use All'
  
  this.widgs.panels = uiUtils.makePanel('vertical',
    [
      uiUtils.makeTextPanel('Training Data','projects/GLANCE/TRAINING/LCMAP_stable_segments_measures_training_coefs_remapped','horizontal'),
      uiUtils.makeTextPanel('Attribute','LC_Num', 'horizontal')
    ]
  )
  
  /**
   * List of functions for the selector widget
   */
  this.funcs = [
    this.useAllTraining, 
    this.useRegionTraining,
  ]
  
  this.widgs.dropdown = uiUtils.makePanel('horizontal',
    [
      ui.Label('Define training data strategy'),
      ui.Select({
        items: self.trainingOptions,
        onChange: function(i) {
          self.trainingStrategy = i
          self.fc = ee.FeatureCollection(
            self.widgs.panels.widgets().get(0).widgets().get(1).getValue())
        }
      })
    ])
  
  this.widgs.all = uiUtils.makePanel('vertical',
    [
      ui.Label('Training data procedure',visLabels),
      self.widgs.dropdown,
      self.widgs.panels
    ]
  )
}



//............. STUDY AREA ................//

/**
 * Draw a box on the map
 * 
 * Written by Justin Braaten (I think): https://emapr.github.io/LT-GEE/
 * https://code.earthengine.google.com/82b08b69bd596ada4747cb4bb7ea9526
 * 
 * This function allows you to click on the map and after 5 clicks, the
 * locations and joined, making a Polygon. This polygon can be used as the
 * geographic extent of the analysis. 
 */ 
var DrawAreaTool = function(map) {
  var drawingToolLayer = ui.Map.Layer({name: 'Area Selection Tool', visParams: {palette:'#4A8BF4', color:'#4A8BF4' }});

  this.map = map;
  this.selection = null;
  this.active = false;
  this.points = [];
  this.area = null;
  
  this.listeners = [];

  var tool = this;
  
  this.initialize = function() {
    this.map.onClick(this.onMouseClick);
    map.layers().reset()
    map.layers().set(0, drawingToolLayer);
  };
  
  this.startDrawing = function() {
    this.active = true;
    this.points = [];

    this.map.style().set('cursor', 'crosshair');
    drawingToolLayer.setShown(true);
  };
  
  this.stopDrawing = function() {
    tool.active = false;
    tool.map.style().set('cursor', 'hand');

    if(tool.points.length < 2) {
      return;
    }

    var closedPoints = tool.points.slice(0,-1);
    tool.area = ee.Geometry.Polygon(closedPoints)///.bounds();
    
    var empty = ee.Image().byte();
    var test = empty.paint({
      featureCollection: ee.FeatureCollection(tool.area),
      color: 1,
      width: 4
    });
  
    drawingToolLayer.setEeObject(test);

    tool.listeners.map(function(listener) {
      listener(tool.area);
    });
  };
  
  this.onMouseClick = function(coords) {
    if(!tool.active) {
      return;
    }
    
    tool.points.push([coords.lon, coords.lat]);

    var geom = tool.points.length > 1 ? ee.Geometry.LineString(tool.points) : ee.Geometry.Point(tool.points[0]);
    drawingToolLayer.setEeObject(geom);

    if(tool.points.length > 4) {
      tool.stopDrawing();
    }
  };
  
  this.onFinished = function(listener) {
    tool.listeners.push(listener);
  };
  
  this.initialize();
};

var region = function(theMap, grids,regions, visLabels) {
  var self = this
  this.widgs = {}
  this.widgs.geoPanel = ui.Panel()
  this.regions = regions
  this.theMap = theMap
  this.regionTypes = ['Select Method','Draw on Map','Single Tile','Tile Intersecting Point','Multiple Tiles','Draw Multiple Tiles on Map']

  
  this.widgs.singleTilePanel = uiUtils.makePanel('horizontal',
    [
      ui.Label({value:'Vertical #:', style:{color:'red'}}),
      ui.Textbox({value:32, style:{stretch: 'horizontal'}}),
      ui.Label({value:'Horizontal #:', style:{color:'red'}}),
      ui.Textbox({value:61, style:{stretch: 'horizontal'}}) ,
      ui.Label({value:'Region', style:{color:'red'}}),
      ui.Select({items:self.regions,value: self.regions[5], style:{stretch: 'horizontal'}}) 
    ]
  )
  
  
  this.widgs.multiplePanelStart = uiUtils.makePanel('horizontal',
    [
      ui.Label({value:'Vertical # Min:', style:{color:'red'}}),
      ui.Textbox({value:30, style:{stretch: 'horizontal'}}),
      ui.Label({value:'Horizontal # Min:', style:{color:'red'}}),
      ui.Textbox({value:60, style:{stretch: 'horizontal'}}),
      ui.Label({value:'Region', style:{color:'red'}}),
      ui.Select({items:self.regions,value: self.regions[0], style:{stretch: 'horizontal'}}) 
    ]
  )
  
  
  this.widgs.multiplePanelEnd = uiUtils.makePanel('vertical',
    [
      ui.Label({value:'Vertical # Max:', style:{color:'red'}}),
      ui.Textbox({value:35, style:{stretch: 'horizontal'}}),
      ui.Label({value:'Horizontal # End:', style:{color:'red'}}),
      ui.Textbox({value:65, style:{stretch: 'horizontal'}}),
    ]
  )
  
  /**
   * Helper function for drawing output extent. 
   * 
   * This function faciliates the drawing of the output extent using the
   * DrawAreaTool() function. 
   */ 
  this.doAreaTool = function() {
    self.widgs.geoPanel.add(ui.Label('Slowly click five points on the map and the application will generate a rectangle for the output extent geometry.'))
    var tool = new DrawAreaTool(self.theMap);
    tool.startDrawing();
    tool.onFinished(function(geometry) {
      self.outGeo = ee.Feature(geometry);
    });
    
  }
  
  /**
   * Helper function for drawing output extent and finding overlapping tiles
   * 
   * This function faciliates the drawing of the output extent using the
   * DrawAreaTool() function. 
   */ 
   this.drawMultipleTiles = function() {
    self.widgs.geoPanel.add(ui.Label('Slowly click five points on the map and the application will generate a rectangle for the output extent geometry.'))
    var tool = new DrawAreaTool(self.theMap);
    tool.startDrawing();
    tool.onFinished(function(geometry) {
      var tempGeo = grids.filterBounds(geometry);
  
      tempGeo.size().evaluate(function(val) {
        if (val > 0) {
          self.outGeos = ee.FeatureCollection(tempGeo)
          theMap.addLayer(self.outGeos, {},'Output Geometry')
          theMap.centerObject(self.outGeos)
          self.outGeosSize = val
        } else {
          print('No overlapping tiles found!')
        }
      })
    })
    
  }
  
  /**
   * Specify a single tile. 
   * 
   * This function filters the GLANCE global grid based on the users
   * input properties in the GUI. 
   */ 
  this.doSingleTile = function() {
    self.widgs.geoPanel.add(self.widgs.singleTilePanel)
  
    var tempGeo
    var validateTile = ui.Button('Load Tile', function(){
      h = Number(self.widgs.singleTilePanel.widgets().get(3).getValue())
      v = Number(self.widgs.singleTilePanel.widgets().get(1).getValue())
      r = String(self.widgs.singleTilePanel.widgets().get(5).getValue())
      tempGeo = grids.filterMetadata('horizontal','equals',h)
        .filterMetadata('vertical','equals',v)
        .filterMetadata('zone','equals',r)
  
      tempGeo.size().evaluate(function(val) { 
        if (val > 0) {
          self.outGeo = ee.Feature(tempGeo.first())
          theMap.addLayer(self.outGeo, {},'Output Geometry')
          theMap.centerObject(self.outGeo)
        }
        else {
          print('No Tile Found!')
        }
      })
    })
    self.widgs.geoPanel.add(validateTile)
  }
  
  /**
   * Find a single tile by clicking on the map. 
   * 
   * This function filters the GLANCE global grid based on the intersection of
   * a point clicked on the map. 
   */ 
  this.doPoint = function() {
    self.hasClicked = false
    theMap.style().set('cursor', 'crosshair');
    self.widgs.geoPanel.add(ui.Label('Click a location on the map to load the intersecting tile'))
    theMap.onClick(function(coords) {
      theMap.layers().reset()
      var latitude = coords.lat
      var longitude = coords.lon
      var point = ee.Geometry.Point([longitude, latitude])
      var tempGeo = grids.filterBounds(point)
      
      theMap.layers().set(0, point)
      tempGeo.size().evaluate(function(val) { 
        if (val > 0) {
          self.outGeo = ee.Feature(tempGeo.first())
          theMap.addLayer(self.outGeo, {},'Output Geometry')
          theMap.centerObject(self.outGeo)
        }
     })
     theMap.unlisten()
    })
  }
  
  /**
   * Specify a range of tiles. 
   * 
   * This function filters the GLANCE global grid based on a range of
   * the users input properties in the GUI. 
   */ 
  this.doMultipleTiles = function() {
    
    self.widgs.geoPanel.add(self.widgs.multiplePanelStart)
    self.widgs.geoPanel.add(self.widgs.multiplePanelEnd)
  
    var tempGeo
    var validateTile = ui.Button('Load Tiles', function(){
      var h1 = Number(self.widgs.multiplePanelStart.widgets().get(3).getValue())
      var v1 = Number(self.widgs.multiplePanelStart.widgets().get(1).getValue())
      
      var h2 = Number(self.widgs.multiplePanelEnd.widgets().get(3).getValue())
      var v2 = Number(self.widgs.multiplePanelEnd.widgets().get(1).getValue())
  
      var r = String(self.widgs.multiplePanelStart.widgets().get(5).getValue())
      tempGeo = grids.filterMetadata('horizontal','greater_than',h1)
        .filterMetadata('horizontal','less_than',h2)
        .filterMetadata('vertical','greater_than',v1)
        .filterMetadata('vertical','less_than',v2)
        .filterMetadata('zone','equals',r)
  
      tempGeo.size().evaluate(function(val) {
        if (val > 0) {
          self.outGeo = ee.FeatureCollection(tempGeo)
          theMap.addLayer(self.outGeo, {},'Output Geometry')
          theMap.centerObject(self.outGeo)
          self.outGeosSize = val
        } else if (val === 0) {
          print('No Tile Found!')
        }
      })
    })
    self.widgs.geoPanel.add(validateTile)
  }
  
  this.widgs.selectRegion = uiUtils.makePanel('horizontal',
    [
      ui.Label({value:'Define Study Region:', style:{color:'black'}}),
      ui.Select({
        value: 'Select Method',
        items: self.regionTypes,
        onChange: function(reg) {
          self.widgs.geoPanel.clear()
          Map.unlisten()
          theMap.layers().reset()
          var index = self.regionTypes.indexOf(reg) - 1
          self.geoType = index
          
          var regionFuncs = [
            self.doAreaTool, 
            self.doSingleTile, 
            self.doPoint, 
            self.doMultipleTiles, 
            self.drawMultipleTiles
          ]
          var regionFunc = regionFuncs[index]
          regionFunc(reg)
        }
      })
    ]
  );

  this.widgs.all = uiUtils.makePanel('vertical',
    [
      ui.Label('Define Output Region',visLabels),
      this.widgs.selectRegion,
      self.widgs.geoPanel
    ]
  )
}

/**
 * Classifier parameters
 */
var classifier = function(classifierList, eeClassifiers, visLabels) {
  var self = this
  this.widgs = {}
  this.classifierList = classifierList
  this.eeClassifiers = eeClassifiers
  this.visLabels = visLabels
  this.widgs.classifierParams = uiUtils.makePanel('vertical', [])

  this.randomForestOptions = function() {
    self.widgs.classifierParams.add(uiUtils.makeTextPanel('numTrees',200,'horizontal'))
    self.widgs.classifierParams.add(uiUtils.makeTextPanel('variablesPerSplit',null, 'horizontal'))
  }
    
  this.changeClassifier = function(i) {
    var index = self.classifierList.indexOf(i)
    self.classifier = self.eeClassifiers[index]
    self.widgs.classifierParams.clear()
    if (i == 'RandomForest') {
      self.randomForestOptions()
    }
  }
  
  this.dateList = '2001-01-01'
  this.widgs.dateBox = uiUtils.makeTextPanel('Date',self.dateList,'horizontal')
  this.widgs.dateBox.widgets().get(1).onChange(function(str) {
    self.dateList = str
  })

  this.widgs.classifierSelector = ui.Panel(
    [
      ui.Label({value:'Classifier', style:{stretch: 'horizontal', color:'black'}}),
      ui.Select({
        items: self.classifierList, 
        onChange: self.changeClassifier,
        style:{stretch: 'horizontal',
        }}),
  
    ],
    ui.Panel.Layout.Flow('horizontal')
  );
  
  this.widgs.all = uiUtils.makePanel('vertical',
    [
      ui.Label('Classification Parameters',self.visLabels),
      self.widgs.dateBox,  
      self.widgs.classifierSelector,
      self.widgs.classifierParams
    ]
  )
}

// PREDICTORS 
var predictors = function(visLabels, coefs, props) {
  var self = this
  this.widgs = []
  this.widgs.bandChecks = uiUtils.makePanel('vertical', [])
  this.widgs.coefChecks = uiUtils.makePanel('vertical', [])

    
  this.widgs.inputCheckboxes = []
  this.inputBands = []
  this.inputCoefs = []
  this.ancillary = []
  
  this.fillInputPanels = function(i) {
    self.bands = i
    
    for (var b = 0; b < i.length; b++) {
      var newCheck = uiUtils.makeCheckbox(i[b], self.inputBands)
      self.widgs.inputCheckboxes.push(newCheck)
      self.widgs.bandChecks.add(newCheck)
      self.inputBands.push(i[b])
    }

    for (var c = 0; c < coefs.length; c++) {
      var newCheck = uiUtils.makeCheckbox(coefs[c], self.inputCoefs)
      self.widgs.inputCheckboxes.push(newCheck)
      self.widgs.coefChecks.add(newCheck)
      self.inputCoefs.push(coefs[c])
    }
  }
  this.ancillary.push('Elevation')
  this.ancillary.push('Aspect')
  this.ancillary.push('DEM Slope')
  
  this.widgs.elevation = uiUtils.makePanel('vertical', 
    [
      uiUtils.makePanel('horizontal',
        [
          uiUtils.makeCheckbox('Elevation', self.ancillary), 
          uiUtils.makeCheckbox('Aspect', self.ancillary)
        ]
      ),
      uiUtils.makePanel('horizontal',
        [
          uiUtils.makeCheckbox('DEM Slope', self.ancillary)
        ]),
    ]
  )
  
  this.widgs.climate = uiUtils.makePanel('vertical', 
    [
      uiUtils.makePanel('horizontal',
        [
          uiUtils.makeCheckbox('Rainfall', self.ancillary), 
          uiUtils.makeCheckbox('Temperature', self.ancillary)
        ]
      )
    ]
  )
  

  this.widgs.checks = uiUtils.makePanel(
    'horizontal', 
    [self.widgs.bandChecks, self.widgs.coefChecks])
  this.widgs.all = uiUtils.makePanel('vertical', 
    [
      ui.Label('Predictor Variables',visLabels),
      ui.Label('CCDC Model Parameters'),
      self.widgs.checks,
      ui.Label({value:'Elevation inputs: ', style: {stretch: 'both'}}),
      self.widgs.elevation,
      ui.Label({value:'Climate inputs: ', style: {stretch: 'both'}}),
      self.widgs.climate
    ]
  )
}


// Code for calculating  LC at a date
/**
 * Calculate landcover at a date based on pre-classified segments
 * 
 * @param {ee.Image}   segs               classified ccd segment image 
 * @param {String}     date               date of land cover to retrieve in format 'YYYY-MM-DD'
 * @param {Number}     numberOfSegments   number of segments in classification image
 * @param {String}     ccdVersion         version of ccd used for classification
 * @param {String}     metadataFilter     metadata used for classification of ccd
 * @param {String}     behavior           behavior when date is in between segments ('none','before','after')
 * 
 * @returns {ee.Image} matchingDate       landcover classification image at date specified in parameter
 */ 
var getLcAtDate = function(segs, date, numberOfSegments, 
  ccdVersion, metadataFilter, behavior) {
  
  // Hard code for now
  var bandNames = ["BLUE","GREEN","RED","NIR","SWIR1","SWIR2","TEMP"]
  var inputFeatures = ["INTP", "SLP","PHASE","AMPLITUDE","COS","SIN","COS2","SIN2"] 


  // CCDC Collection and 'system:index' metadata ftilter
  var ccdcCollection = ee.ImageCollection("projects/CCDC/" + ccdVersion)

  // Get CCDC coefficients
  var ccdcCollectionFiltered = ccdcCollection
    .filterMetadata('system:index', 'starts_with',metadataFilter)

  // CCDC mosaic image
  var ccdc = ccdcCollectionFiltered.mosaic()

  // Make a coefficient image
  var newccd = ccdcUtils.newFillNoData(ccdc, 8, bandNames.length) 

  // Turn array image into image
  var specImage = ccdcUtils.newBuildCcdcImage(newccd, numberOfSegments, bandNames)

  var tStarts = specImage.select('.*tStart')

  var tEnds = specImage.select('.*tEnd')

  var dateFormatted = dateUtils.convertDate({
    inputFormat: 3,
    inputDate: date,
    outputFormat: 1
  })

  if (behavior == 'before') {
    var dateMask = tStarts.lt(dateFormatted)
    var matchingDate =  segs.updateMask(dateMask).reduce(ee.Reducer.lastNonNull())
  } else if (behavior == 'after') {
    var dateMask = tEnds.gt(dateFormatted)
    var matchingDate =  segs.updateMask(dateMask).reduce(ee.Reducer.firstNonNull()) 
  } else {
    var dateMask = tStarts.lt(dateFormatted).and(tEnds.gt(dateFormatted))
    var matchingDate =  segs.updateMask(dateMask).reduce(ee.Reducer.firstNonNull()) 
  }

  return matchingDate
}


exports = {
  classifyGrids: classifyGrids,
  getMiddleDate: getMiddleDate,
  makeGrids: makeGrids,
  subsetSingleTraining: subsetSingleTraining,
  subsetAllTraining: subsetAllTraining,
  trainAndClassify: trainAndClassify,
  getBinaryLabel: getBinaryLabel,
  getClassProbs: getClassProbs,
  getTrainingCoefsAtDate: getTrainingCoefsAtDate,
  subsetTraining: subsetTraining,
  training: training,
  region: region,
  classifier: classifier,
  predictors: predictors,
  remapLC: remapLC,
  getLcAtDate: getLcAtDate

}






